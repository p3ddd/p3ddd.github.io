[{"content":"Windows 下关了 VS Code 以后有时会发现项目文件夹仍然被占用，无法移动也无法重命名。\n打开资源管理器，在性能页面打开资源监视器（Win10 在下方，Win11 在右上角三个点），或者也可以直接搜索。 点击 CPU 一栏，在关联的句柄后面的框里输入被占用的文件夹的名字，回车搜索。 我这里发现文件夹被 git 占用了，右键结束进程就好了。\n","date":"2023-09-22T14:36:51+08:00","permalink":"https://petrichor.net.cn/p/vscode-the-folder-is-occupied/","title":"解决 VS Code 关闭以后项目文件夹仍被占用"},{"content":"我的笔记本：\nOS: Windows 11 家庭中文版 22H2 CPU: Intel(R) Core(TM) i5-1035G7 CPU @ 1.20GHz 1.50 GHz GPU: MX250 RAM: 16.0 GB 简介 LLaMA(Large Language Model Meta AI) 是 Meta 发布的大语言模型。2023年7月，Meta 公司发布了人工智能模型 LLaMA-2 的开源商用版本，意味着大模型应用进入了“免费时代”，初创公司也能够以低廉的价格来创建类似 ChatGPT 这样的聊天机器人。1\nLLaMA-Alpaca-2 2 基于 Meta 发布的可商用大模型 Llama-2 开发，是中文 LLaMA \u0026amp; Alpaca 大模型的第二期项目，开源了中文 LLaMA-2 基座模型和 Alpaca-2 指令精调大模型。\n这些模型在原版 Llama-2 的基础上扩充并优化了中文词表，使用了大规模中文数据进行增量预训练，进一步提升了中文基础语义和指令理解能力，相比一代相关模型获得了显著性能提升。\n本文选择了最小的 7B 版本。\n下载模型 到项目的 Github 仓库上找到 完整模型下载链接，选择合适的模型。\n我这里选择的是 Chinese-Alpaca-2-7B 指令模型，模型大小 12.9 GB，适用场景为指令理解：问答、写作、聊天、交互等。\n部署 llama.cpp 3 Github 上的介绍如下：\nThe main goal of llama.cpp is to run the LLaMA model using 4-bit integer quantization on a MacBook\n在 Windows 上编译需要使用 CMake，第一次编译失败了，这里我们可以直接下载 Release。\n使用 llama.cpp 对模型进行量化 4，量化之后模型大小为 3.68G，精度降低但是内存要求小了很多。\n1 2 3 python3 convert.py --outtype f16 \u0026lt;你的hf模型目录\u0026gt; # 生成一个 ggml 格式的 bin 文件 quantize.exe \u0026lt;需要使用的f16/f32模型地址\u0026gt; \u0026lt;生成的q4模型地址\u0026gt; q4_0 使用 llama.cpp 加载模型：\n1 2 3 4 # 基本运行 main -m \u0026lt;q4模型bin文件路径\u0026gt; -p 你的prompt # 交互问答 main -m \u0026lt;q4模型bin文件路径\u0026gt; -ins 到这里已经能正常使用了，接下来介绍另一个工具。\ntext-generation-webui text-generation-webui 5 是一个可以运行各种大模型的网页版部署工具。\n在打开的网页中，依次选择 Chat setting -\u0026gt; Instruction template，在 Instruction template 中下拉选择 Llama-v2，并将 Context 输入框中的 Answer the questions. 提示语替换为 You are a helpful assistant. 你是一个乐于助人的助手。，最后回到 Text generation 界面，在 input 输入框中输入你的指令，即可与 chinese-alpaca-2 对话了。\n最后 一开始没有进行量化就跑了一下，风扇瞬间响起来了，紧接着鼠标开始变卡了，我当时是开着任务管理器的，切出来一看内存已经满了，应该是爆内存了。赶紧 Ctrl+C 把项目停下来，内存占用又下来了。\n打开我的电脑一看，C 盘就这一会儿的功夫已经少了十几个 G，变成了刺眼的红色，还好在重启之后又恢复了。\nhttps://baike.baidu.com/item/LLaMA/62812215\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/ymcui/Chinese-LLaMA-Alpaca-2\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/ggerganov/llama.cpp\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://zhuanlan.zhihu.com/p/634120727\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/oobabooga/text-generation-webui\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-08-20T12:08:49+08:00","permalink":"https://petrichor.net.cn/p/chinese-llama-alpaca-2/","title":"在笔记本上跑一下大模型"},{"content":"在 Windows 中，按 F1 会使用浏览器打开帮助页面，而我的电脑 F1 - F12 默认是功能键，如果不小心按到 F1 就会打开浏览器，很烦。现在找到一个办法，可以把这个功能关掉。\n方法 使用管理员权限运行这个脚本：\n1 2 3 4 @echo off taskkill /f /im HelpPane.exe takeown /f %WinDir%\\HelpPane.exe icacls %WinDir%\\HelpPane.exe /deny Everyone:(X) 来源：https://answers.microsoft.com/en-us/windows/forum/all/how-do-i-stop-f1-opening-a-browser-window-on-how/7f68f9b8-9d87-43a5-9a79-db87702254b5\n输出\n成功: 已终止进程 \u0026ldquo;HelpPane.exe\u0026rdquo;，其 PID 为 5600。\n成功: 此文件(或文件夹): \u0026ldquo;C:\\Windows\\HelpPane.exe\u0026rdquo; 现在由用户 \u0026ldquo;？？\\用户名\u0026rdquo; 所有。\n已处理的文件: C:\\Windows\\HelpPane.exe 已成功处理 1 个文件; 处理 0 个文件时失败\n命令详解 taskkill 适用范围：Windows Server 2022、Windows Server 2019、Windows Server 2016、Windows Server 2012 R2、Windows Server 2012\n结束一个或多个任务或进程。 可以通过进程 ID 或图像名称结束进程。 您可以使用 tasklist 命令 命令来确定进程 ID (PID) 以结束进程。\n备注：此命令替换 kill 工具。\n1 taskkill [/s \u0026lt;computer\u0026gt; [/u [\u0026lt;domain\u0026gt;\\]\u0026lt;username\u0026gt; [/p [\u0026lt;password\u0026gt;]]]] {[/fi \u0026lt;filter\u0026gt;] [...] [/pid \u0026lt;processID\u0026gt; | /im \u0026lt;imagename\u0026gt;]} [/f] [/t] takeown 使管理员作为文件的所有者，恢复对之前被拒文件的访问权限。 此命令通常用于批处理文件。\n1 takeown [/s \u0026lt;computer\u0026gt; [/u [\u0026lt;domain\u0026gt;\\]\u0026lt;username\u0026gt; [/p [\u0026lt;password\u0026gt;]]]] /f \u0026lt;filename\u0026gt; [/a] [/r [/d {Y|N}]] icacls 显示或修改指定文件上的随机访问控制列表 (DACL)，并将存储的 DACL 应用于指定目录中的文件。\n备注：此命令替换已弃用 的 cacls 命令\n1 2 icacls \u0026lt;filename\u0026gt; [/grant[:r] \u0026lt;sid\u0026gt;:\u0026lt;perm\u0026gt;[...]] [/deny \u0026lt;sid\u0026gt;:\u0026lt;perm\u0026gt;[...]] [/remove[:g|:d]] \u0026lt;sid\u0026gt;[...]] [/t] [/c] [/l] [/q] [/setintegritylevel \u0026lt;Level\u0026gt;:\u0026lt;policy\u0026gt;[...]] icacls \u0026lt;directory\u0026gt; [/substitute \u0026lt;sidold\u0026gt; \u0026lt;sidnew\u0026gt; [...]] [/restore \u0026lt;aclfile\u0026gt; [/c] [/l] [/q]] ","date":"2022-09-16T16:12:18+08:00","permalink":"https://petrichor.net.cn/p/stop-f1-opening-browser/","title":"如何让 F1 不再打开帮助页面"},{"content":"HTTP content-type 对照表 文件扩展名 Content-Type(Mime-Type) 文件扩展名 Content-Type(Mime-Type) .*（ 二进制流，不知道下载文件类型） application/octet-stream .tif image/tiff .001 application/x-001 .301 application/x-301 .323 text/h323 .906 application/x-906 .907 drawing/907 .a11 application/x-a11 .acp audio/x-mei-aac .ai application/postscript .aif audio/aiff .aifc audio/aiff .aiff audio/aiff .anv application/x-anv .asa text/asa .asf video/x-ms-asf .asp text/asp .asx video/x-ms-asf .au audio/basic .avi video/avi .awf application/vnd.adobe.workflow .biz text/xml .bmp application/x-bmp .bot application/x-bot .c4t application/x-c4t .c90 application/x-c90 .cal application/x-cals .cat application/vnd.ms-pki.seccat .cdf application/x-netcdf .cdr application/x-cdr .cel application/x-cel .cer application/x-x509-ca-cert .cg4 application/x-g4 .cgm application/x-cgm .cit application/x-cit .class java/* .cml text/xml .cmp application/x-cmp .cmx application/x-cmx .cot application/x-cot .crl application/pkix-crl .crt application/x-x509-ca-cert .csi application/x-csi .css text/css .cut application/x-cut .dbf application/x-dbf .dbm application/x-dbm .dbx application/x-dbx .dcd text/xml .dcx application/x-dcx .der application/x-x509-ca-cert .dgn application/x-dgn .dib application/x-dib .dll application/x-msdownload .doc application/msword .dot application/msword .drw application/x-drw .dtd text/xml .dwf Model/vnd.dwf .dwf application/x-dwf .dwg application/x-dwg .dxb application/x-dxb .dxf application/x-dxf .edn application/vnd.adobe.edn .emf application/x-emf .eml message/rfc822 .ent text/xml .epi application/x-epi .eps application/x-ps .eps application/postscript .etd application/x-ebx .exe application/x-msdownload .fax image/fax .fdf application/vnd.fdf .fif application/fractals .fo text/xml .frm application/x-frm .g4 application/x-g4 .gbr application/x-gbr . application/x- .gif image/gif .gl2 application/x-gl2 .gp4 application/x-gp4 .hgl application/x-hgl .hmr application/x-hmr .hpg application/x-hpgl .hpl application/x-hpl .hqx application/mac-binhex40 .hrf application/x-hrf .hta application/hta .htc text/x-component .htm text/html .html text/html .htt text/webviewhtml .htx text/html .icb application/x-icb .ico image/x-icon .ico application/x-ico .iff application/x-iff .ig4 application/x-g4 .igs application/x-igs .iii application/x-iphone .img application/x-img .ins application/x-internet-signup .isp application/x-internet-signup .IVF video/x-ivf .java java/* .jfif image/jpeg .jpe image/jpeg .jpe application/x-jpe .jpeg image/jpeg .jpg image/jpeg .jpg application/x-jpg .js application/x-javascript .jsp text/html .la1 audio/x-liquid-file .lar application/x-laplayer-reg .latex application/x-latex .lavs audio/x-liquid-secure .lbm application/x-lbm .lmsff audio/x-la-lms .ls application/x-javascript .ltr application/x-ltr .m1v video/x-mpeg .m2v video/x-mpeg .m3u audio/mpegurl .m4e video/mpeg4 .mac application/x-mac .man application/x-troff-man .math text/xml .mdb application/msaccess .mdb application/x-mdb .mfp application/x-shockwave-flash .mht message/rfc822 .mhtml message/rfc822 .mi application/x-mi .mid audio/mid .midi audio/mid .mil application/x-mil .mml text/xml .mnd audio/x-musicnet-download .mns audio/x-musicnet-stream .mocha application/x-javascript .movie video/x-sgi-movie .mp1 audio/mp1 .mp2 audio/mp2 .mp2v video/mpeg .mp3 audio/mp3 .mp4 video/mpeg4 .mpa video/x-mpg .mpd application/vnd.ms-project .mpe video/x-mpeg .mpeg video/mpg .mpg video/mpg .mpga audio/rn-mpeg .mpp application/vnd.ms-project .mps video/x-mpeg .mpt application/vnd.ms-project .mpv video/mpg .mpv2 video/mpeg .mpw application/vnd.ms-project .mpx application/vnd.ms-project .mtx text/xml .mxp application/x-mmxp .net image/pnetvue .nrf application/x-nrf .nws message/rfc822 .odc text/x-ms-odc .out application/x-out .p10 application/pkcs10 .p12 application/x-pkcs12 .p7b application/x-pkcs7-certificates .p7c application/pkcs7-mime .p7m application/pkcs7-mime .p7r application/x-pkcs7-certreqresp .p7s application/pkcs7-signature .pc5 application/x-pc5 .pci application/x-pci .pcl application/x-pcl .pcx application/x-pcx .pdf application/pdf .pdf application/pdf .pdx application/vnd.adobe.pdx .pfx application/x-pkcs12 .pgl application/x-pgl .pic application/x-pic .pko application/vnd.ms-pki.pko .pl application/x-perl .plg text/html .pls audio/scpls .plt application/x-plt .png image/png .png application/x-png .pot application/vnd.ms-powerpoint .ppa application/vnd.ms-powerpoint .ppm application/x-ppm .pps application/vnd.ms-powerpoint .ppt application/vnd.ms-powerpoint .ppt application/x-ppt .pr application/x-pr .prf application/pics-rules .prn application/x-prn .prt application/x-prt .ps application/x-ps .ps application/postscript .ptn application/x-ptn .pwz application/vnd.ms-powerpoint .r3t text/vnd.rn-realtext3d .ra audio/vnd.rn-realaudio .ram audio/x-pn-realaudio .ras application/x-ras .rat application/rat-file .rdf text/xml .rec application/vnd.rn-recording .red application/x-red .rgb application/x-rgb .rjs application/vnd.rn-realsystem-rjs .rjt application/vnd.rn-realsystem-rjt .rlc application/x-rlc .rle application/x-rle .rm application/vnd.rn-realmedia .rmf application/vnd.adobe.rmf .rmi audio/mid .rmj application/vnd.rn-realsystem-rmj .rmm audio/x-pn-realaudio .rmp application/vnd.rn-rn_music_package .rms application/vnd.rn-realmedia-secure .rmvb application/vnd.rn-realmedia-vbr .rmx application/vnd.rn-realsystem-rmx .rnx application/vnd.rn-realplayer .rp image/vnd.rn-realpix .rpm audio/x-pn-realaudio-plugin .rsml application/vnd.rn-rsml .rt text/vnd.rn-realtext .rtf application/msword .rtf application/x-rtf .rv video/vnd.rn-realvideo .sam application/x-sam .sat application/x-sat .sdp application/sdp .sdw application/x-sdw .sit application/x-stuffit .slb application/x-slb .sld application/x-sld .slk drawing/x-slk .smi application/smil .smil application/smil .smk application/x-smk .snd audio/basic .sol text/plain .sor text/plain .spc application/x-pkcs7-certificates .spl application/futuresplash .spp text/xml .ssm application/streamingmedia .sst application/vnd.ms-pki.certstore .stl application/vnd.ms-pki.stl .stm text/html .sty application/x-sty .svg text/xml .swf application/x-shockwave-flash .tdf application/x-tdf .tg4 application/x-tg4 .tga application/x-tga .tif image/tiff .tif application/x-tif .tiff image/tiff .tld text/xml .top drawing/x-top .torrent application/x-bittorrent .tsd text/xml .txt text/plain .uin application/x-icq .uls text/iuls .vcf text/x-vcard .vda application/x-vda .vdx application/vnd.visio .vml text/xml .vpg application/x-vpeg005 .vsd application/vnd.visio .vsd application/x-vsd .vss application/vnd.visio .vst application/vnd.visio .vst application/x-vst .vsw application/vnd.visio .vsx application/vnd.visio .vtx application/vnd.visio .vxml text/xml .wav audio/wav .wax audio/x-ms-wax .wb1 application/x-wb1 .wb2 application/x-wb2 .wb3 application/x-wb3 .wbmp image/vnd.wap.wbmp .wiz application/msword .wk3 application/x-wk3 .wk4 application/x-wk4 .wkq application/x-wkq .wks application/x-wks .wm video/x-ms-wm .wma audio/x-ms-wma .wmd application/x-ms-wmd .wmf application/x-wmf .wml text/vnd.wap.wml .wmv video/x-ms-wmv .wmx video/x-ms-wmx .wmz application/x-ms-wmz .wp6 application/x-wp6 .wpd application/x-wpd .wpg application/x-wpg .wpl application/vnd.ms-wpl .wq1 application/x-wq1 .wr1 application/x-wr1 .wri application/x-wri .wrk application/x-wrk .ws application/x-ws .ws2 application/x-ws .wsc text/scriptlet .wsdl text/xml .wvx video/x-ms-wvx .xdp application/vnd.adobe.xdp .xdr text/xml .xfd application/vnd.adobe.xfd .xfdf application/vnd.adobe.xfdf .xhtml text/html .xls application/vnd.ms-excel .xls application/x-xls .xlw application/x-xlw .xml text/xml .xpl audio/scpls .xq text/xml .xql text/xml .xquery text/xml .xsd text/xml .xsl text/xml .xslt text/xml .xwd application/x-xwd .x_b application/x-x_b .sis application/vnd.symbian.install .sisx application/vnd.symbian.install .x_t application/x-x_t .ipa application/vnd.iphone .apk application/vnd.android.package-archive .xap application/x-silverlight-app ","date":"2022-05-06T20:15:31+08:00","permalink":"https://petrichor.net.cn/p/http-content-type/","title":"HTTP 中的 Content-Type"},{"content":"SSH 配置多个账户 当需要使用多个远程主机或 Git 账户时，使用 SSH 配置文件~/.ssh/config 会很方便。\n常用配置项 可以通过 man ssh_config 命令来查看此配置文件的具体语法\nHost 别名 HostName 主机名，IP 或域名 Port 端口，默认为 22 User 用户名 IdentityFile 密钥文件的路径，可以指定多个，会依次尝试 IdentitiesOnly 只接受 SSH Key 登录 PreferredAuthentications 强制使用 Public Key 验证 转义符 %d 本地用户目录 %u 本地用户名称 %l 本地主机名 %h 远程主机名 %r 远程用户名 示例 1 2 3 4 5 6 Host myserver HostName 12.34.56.78 # 服务器地址 Port 22 # ssh 端口号 User ubuntu # 用户名 IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes 配置好以后，就可以直接使用别名登录远程主机了：ssh myserver 。\n多个主机可以使用同一个密钥，也可以分别使用各自的密钥。若使用相同密钥，还可以通过使用转义符简化配置：\n1 2 3 4 Host github.com gitee.com HostName %h User git IdentityFile ~/.ssh/id_rsa_git 验证：\n1 2 ssh -T git@github.com ssh -T git@gitee.com 已经配置好 ssh，git clone 时仍然需要密码 这通常会在我们使用 https 方式克隆时发生，使用 ssh 方式克隆即可，或者是配置一下缓存。默认是不缓存的，每一次连接都会询问你的用户名和密码，我们可以设置保存到硬盘或是内存。\ngit-credential-cache - Helper to temporarily store passwords in memory 存储到内存\ngit-credential-store - Helper to store credentials on disk 存储到硬盘\n临时缓存密码 1 git config --global credential.helper cache 保存密码 1 git config credential.helper store Reference https://git-scm.com/docs/git-credential-cache https://git-scm.com/docs/git-credential-store https://p3terx.com/archives/ssh-configuration-file.html https://p3terx.com/archives/github-multiaccount-ssh-key-settings.html ","date":"2022-05-01T14:44:01+08:00","permalink":"https://petrichor.net.cn/p/ssh-git-config/","title":"SSH 与 Git 多账号配置"},{"content":"我的腾讯云服务器被我{% spoiler 不小心 %}换了 IP，加上之前用的是宝塔面板，现在不想用了，所以重装了系统，这次装的是 Ubuntu20.04 的 Docker 基础镜像，自带 Docker，腾讯云控制台也有对应的容器控制面板，很方便。这里记录一下服务器上各种常用软件的安装方法与过程。持续更新中。。。\noh-my-zsh 安装 zsh 1 sudo apt-get install zsh 如果找不到，先 sudo apt update 一下。\n{% note info zsh 配置文件加载顺序 %}\n1 2 3 4 5 6 7 8 9 10 /etc/zshenv ~/.zshenv /etc/zprofile ~/.zprofile /etc/zshrc ~/.zshrc /etc/zlogin ~/.zlogin ~/.zlogout /etc/zlogout {% endnote %}\n安装 oh-my-zsh 1 sh -c \u0026#34;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\u0026#34; 中间会询问是否把 zsh 设为默认 sh ，这里选择是。\n如果不小心选择了否，可以通过 chsh -s $(which zsh) 重新设置。\n各种插件 zsh-syntax-highlighting - 代码高亮 1 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting zsh-autosuggestions - 自动建议 1 git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions zsh-completions - 自动补全 1 git clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-completions 配置 在 ~/.zshrc 中配置 plugins=(git sudo z zsh-syntax-highlighting zsh-autosuggestions zsh-completions) 。\nsource ~/.zshrc 应用修改后的配置。\nGit 镜像已经内置。\nMongoDB 安装 Import the public key used by the package management system 1 wget -qO - https://www.mongodb.org/static/pgp/server-5.0.asc | sudo apt-key add - The operation should respond with an OK.\nCreate a list file for MongoDB Create the list file /etc/apt/sources.list.d/mongodb-org-5.0.list for your version of Ubuntu.\nClick on the appropriate tab for your version of Ubuntu. If you are unsure of what Ubuntu version the host is running, open a terminal or shell on the host and execute lsb_release -dc.\nThe following instruction is for Ubuntu 20.04 (Focal).\nCreate the /etc/apt/sources.list.d/mongodb-org-5.0.list file for Ubuntu 20.04 (Focal):\n1 echo \u0026#34;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/5.0 multiverse\u0026#34; | sudo tee /etc/apt/sources.list.d/mongodb-org-5.0.list Reload local package database 1 sudo apt-get update Install the MongoDB packages To install the latest stable version, issue the following\n1 sudo apt-get install -y mongodb-org Optional. Although you can specify any available version of MongoDB, apt-get will upgrade the packages when a newer version becomes available. To prevent unintended upgrades, you can pin the package at the currently installed version:\n1 2 3 4 5 6 echo \u0026#34;mongodb-org hold\u0026#34; | sudo dpkg --set-selections echo \u0026#34;mongodb-org-database hold\u0026#34; | sudo dpkg --set-selections echo \u0026#34;mongodb-org-server hold\u0026#34; | sudo dpkg --set-selections echo \u0026#34;mongodb-org-shell hold\u0026#34; | sudo dpkg --set-selections echo \u0026#34;mongodb-org-mongos hold\u0026#34; | sudo dpkg --set-selections echo \u0026#34;mongodb-org-tools hold\u0026#34; | sudo dpkg --set-selections 启动 启动服务\n1 sudo systemctl start mongod 开机自启动服务\n1 sudo systemctl enable mongod systemctl 启动失败\n1 sudo chown mongodb:mongodb /tmp/mongodb-27017.sock 配置 进入 mongo 命令行 1 mongo 使用 admin 数据库（在 mongo 命令行中） 1 use admin 查找所有用户（在 mongo 命令行中） 1 db.system.users.find() 查看数据库角色（在 mongo 命令行中） 1 show roles 1.数据库用户角色：read、readWrite; 2.数据库管理角色：dbAdmin、dbOwner、userAdmin； 3.集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager； 4.备份恢复角色：backup、restore 5.所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase 6.超级用户角色：root\n角色说明\nread：允许用户读取指定数据库； readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限； readWrite：允许用户读写指定数据库； readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限； dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile； dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限； clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限； userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户； userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限； root：只在admin数据库中可用。超级账号，超级权限。\n查看用户（在 mongo 命令行中） 1 show users 创建用户（在 mongo 命令行中） 1 2 3 4 db.createUser({user:\u0026#34;admin\u0026#34;,pwd:\u0026#34;123456\u0026#34;,roles:[\u0026#34;root\u0026#34;]}) db.createUser({user:\u0026#34;admin\u0026#34;,pwd:\u0026#34;123456\u0026#34;,roles:[{role:\u0026#34;root\u0026#34;,db:\u0026#34;admin\u0026#34; }]}) db.createUser({user:\u0026#34;test\u0026#34;,pwd:\u0026#34;test\u0026#34;,roles:[{role:\u0026#34;userAdminAnyDatabase\u0026#34;,db:\u0026#34;admin\u0026#34;}]}) db.createUser({user:\u0026#34;gin\u0026#34;,pwd:\u0026#34;gin\u0026#34;,roles:[{role:\u0026#34;dbOwner\u0026#34;,db:\u0026#34;gin\u0026#34;}]}) {% note caution caution %}\n创建用户时，要切换到目标数据库再创建用户，不然创建的用户还是属于 admin\n{% endnote %}\n登录（在 mongo 命令行中） 1 db.auth(\u0026#39;admin\u0026#39;,\u0026#39;password\u0026#39;) 注意 安装失败，多试几次 sudo apt update {% fold %}\nErr:6 https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/5.0 Release\nCould not wait for server fd - select (11: Resource temporarily unavailable) [IP: 13.35.49.55 443]\nErr:7 https://download.docker.com/linux/ubuntu focal Release\nCould not wait for server fd - select (11: Resource temporarily unavailable) [IP: 13.249.170.87 443]\nReading package lists\u0026hellip; Done\nE: The repository \u0026lsquo;https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/5.0 Release\u0026rsquo; does not have a Release file.\nN: Updating from such a repository can\u0026rsquo;t be done securely, and is therefore disabled by default.\nN: See apt-secure(8) manpage for repository creation and user configuration details.\nE: The repository \u0026lsquo;https://download.docker.com/linux/ubuntu focal Release\u0026rsquo; no longer has a Release file.\nN: Updating from such a repository can\u0026rsquo;t be done securely, and is therefore disabled by default.\nN: See apt-secure(8) manpage for repository creation and user configuration details.\n{% endfold %}\nMysql Server 安装 1 sudo apt install mysql-server 进入 mysql 命令行 1 mysql -uroot 设置密码\nset password for root@localhost = \u0026lsquo;123456\u0026rsquo;;\n1 2 3 4 CREATE DATABASE IF NOT EXISTS lskypro; CREATE USER \u0026#39;lskypro\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;123456\u0026#39;; GRANT ALL PRIVILEGES ON lskypro.* TO \u0026#39;lskypro\u0026#39;@\u0026#39;%\u0026#39; WITH GRANT OPTION; flush privileges; Redis 直接使用 apt 安装\n1 sudo apt install redis-server 使用 redis-cli 验证\n1 redis-cli redis-cli 内设置密码\n1 config set requirepass 123456 命令行指定的密码，重启后无效，想要永久生效则修改配置文件 /etc/redis/redis.conf ，在 requirepass 后添加密码。\n如果想设置远程访问， sudo vim /etc/redis/redis.conf ，需要将 bind 127.0.0.1 ::1 注释掉并且没有设置访问密码，然后将 Protected-mode 设置为 no 。\n{% note info Redis Protected-mode %}\nProtected-mode 是为了禁止公网访问redis cache，加强redis安全的。\n它启用的条件，有两个： 1） 没有bind IP 2） 没有设置访问密码\n{% endnote %}\nGolang 在官网或其他网站如：\nhttps://studygolang.com/dl https://golang.google.cn/dl/ 下载压缩包 如 go1.18.1.linux-amd64.tar.gz , 上传至服务器，然后解压缩：\n1 sudo tar -zxf go1.18.1.linux-amd64.tar.gz -C /usr/local 设置环境变量 1 2 3 4 5 6 7 8 9 export GOROOT=/usr/local/go export GOPATH=/home/ubuntu/go export PATH=$GOROOT/bin:$GOPATH/bin:$PATH export GO111MODULE=on export GOPROXY=https://goproxy.cn,direct export CGO_ENABLED=0 export GOOS=linux export GOARCH=amd64 ➜ ~ go version go version go1.18.1 linux/amd64\nNode.js 1 sudo curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - ## Run **sudo apt-get install -y nodejs** to install Node.js 14.x and npm\n## You may also need development tools to build native addons:\n​ sudo apt-get install gcc g++ make\n## To install the Yarn package manager, run:\n​ curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | gpg \u0026ndash;dearmor | sudo tee /usr/share/keyrings/yarnkey.gpg \u0026gt;/dev/null\n​ echo \u0026ldquo;deb [signed-by=/usr/share/keyrings/yarnkey.gpg] https://dl.yarnpkg.com/debian stable main\u0026rdquo; | sudo tee /etc/apt/sources.list.d/yarn.list\n​ sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install yarn\n换清华源（已过期） 清华源已经将 NodeSource 去掉，下面[使用 n 替代](#使用 n 安装)。\n编辑 /etc/apt/sources.list.d/nodesource.list ， 把 https://deb.nodesource.com/node/ 替换为 https://mirrors.tuna.tsinghua.edu.cn/nodesource/node/ 即可。\n这里是 https://deb.nodesource.com/node_14.x ，改为 https://mirrors.tuna.tsinghua.edu.cn/nodesource/deb_14.x 。\n换源后安装（×） 1 2 sudo apt update sudo apt install nodejs 使用 n 安装 首先要安装 npm，然后用 npm 安装 n，这里先随意下载一个版本。\n1 sudo apt install nodejs npm ➜ ~ npm -v\n6.14.4\n➜ ~ node -v\nv10.19.0\n然后安装 n\n1 npm install -g n 使用 n 切换版本\n1 2 3 4 # 设定环境变量（~/.zshrc） export NODE_MIRROR=https://mirrors.tuna.tsinghua.edu.cn/nodejs-release/ # 然后正常使用 n 即可 sudo n stable ➜ ~ node -v\nv16.15.0\n➜ ~ npm -v\n8.5.5\nnpm 换源 1 npm config set registry \u0026#34;https://registry.npm.taobao.org\u0026#34; 注意 Err:5 https://mirrors.tuna.tsinghua.edu.cn/nodesource/deb_14.x focal Release\nCertificate verification failed: The certificate is NOT trusted. The certificate chain uses expired certificate. Could not handshake: Error in the certificate v\nerification. [IP: 101.6.15.130 443]\n1 sudo apt install ca-certificates --reinstall Nginx 直接 apt 安装就可以。\n1 sudo apt install nginx 1 sudo systemctl start nginx 1 sudo systemctl enable nginx Docker 这次安装的镜像是 docker 基础镜像，内置了 docker，不再记录。\n可以查看另一篇文章：Docker\nGrafana 1 sudo docker run -d --net=host --restart=always --name=grafana grafana/grafana ShowDoc 1 2 sudo docker run -d --name showdoc --user=root --privileged=true -p 4999:80 \\ -v /data/showdoc/html:/var/www/html/ star7th/showdoc MinIO 1 2 3 4 5 6 7 8 9 10 sudo docker run -itd --name minio \\ -p 9000:9000 \\ -p 19000:19000 \\ -d --restart=always \\ -e \u0026#34;MINIO_ROOT_USER=admin\u0026#34; \\ -e \u0026#34;MINIO_ROOT_PASSWORD=123456\u0026#34; \\ -v /data/minio:/data \\ -v /etc/minio:/root/.minio \\ minio/minio server /data \\ --console-address \u0026#39;0.0.0.0:19000\u0026#39; Cloudreve Lsky Pro 2 如果要访问宿主机的 Mysql ，可以在 mysql 配置文件(/etc/mysql/mysql.conf.d/mysqld.cnf)中设置 bind-address 为 0.0.0.0(允许所有 IP 访问)，然后 docker network inspect lskypro_default ，查看容器 IP，在服务器的防火墙中开放此 IP 对 3306 的访问权限。\nEMQX Prometheus Portainer frp ctop Top-like interface for container metrics\nctop provides a concise and condensed overview of real-time metrics for multiple containers:\nhttps://github.com/bcicen/ctop/raw/master/_docs/img/grid.gif\nas well as a single container view for inspecting a specific container.\nctop comes with built-in support for Docker and runC; connectors for other container and cluster systems are planned for future releases.\n安装\n1 2 3 4 echo \u0026#34;deb http://packages.azlux.fr/debian/ buster main\u0026#34; | sudo tee /etc/apt/sources.list.d/azlux.list wget -qO - https://azlux.fr/repo.gpg.key | sudo apt-key add - sudo apt update sudo apt install docker-ctop 未完待续。。。 Reference https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/ https://computingforgeeks.com/how-to-install-mongodb-database-on-ubuntu/ 如何在 Ubuntu 20.04 上安装 Node.js 和 npm （已过期）https://mirror.tuna.tsinghua.edu.cn/help/nodesource/ https://mirror.tuna.tsinghua.edu.cn/help/nodejs-release/ ","date":"2022-04-30T16:59:02+08:00","image":"https://petrichor.net.cn/docker-ubuntu.png","permalink":"https://petrichor.net.cn/p/ubuntu-prepare/","title":"『合集』Ubuntu 常用软件安装（持续更新中。。。）"},{"content":"安装\n1 go install github.com/cnlh/benchmark@latest 测试程序\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;github.com/gin-gonic/gin\u0026#34; func main() { r := gin.New() r.GET(\u0026#34;/ping\u0026#34;, func(ctx *gin.Context) { ctx.String(200, \u0026#34;pong\u0026#34;) }) r.Run(\u0026#34;:8000\u0026#34;) } 使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026gt; benchmark.exe -c 3000 -n 100000 http://127.0.0.1:8000/ping Running 100000 test @ 127.0.0.1:8000 by 3000 connections Request as following format: GET /ping HTTP/1.1 Host: 127.0.0.1:8000 Requests/sec: 44579.28 Transfer/sec: 7.25MB Error(s) : 0 Percentage of the requests served within a certain time (ms) 50% 4 65% 6 75% 8 80% 8 90% 11 95% 14 98% 24 99% 128 100% 833 ","date":"2022-04-30T10:05:56+08:00","permalink":"https://petrichor.net.cn/p/go-benchmark/","title":"Go Benchmark"},{"content":"记录常用 shell 脚本。\nid.sh 1 echo $(sudo lsof -i:7091|grep main|awk \u0026#39;NR==1{print $2}\u0026#39;) start.sh 1 2 sudo nohup go run ./main.go \u0026gt;\u0026gt; web.log 2\u0026gt;\u0026amp;1 \u0026amp; echo $(sudo lsof -i:7091|grep main|awk \u0026#39;NR==1{print $2}\u0026#39;) stop.sh 1 2 3 4 5 6 7 8 9 # 先过滤出 7091 端口，用 grep 过滤出 main，同时用 awk 过滤出第二行的数据 id=$(sudo lsof -i:7091|grep main|awk \u0026#39;NR==1{print $2}\u0026#39;) if [ ! ${id} ] then echo \u0026#34;项目未启动!\u0026#34; else kill -9 $id echo \u0026#34;项目已关闭!\u0026#34; fi restart.sh 1 2 3 4 5 6 7 8 9 10 11 id=$(sudo lsof -i:7091|grep main|awk \u0026#39;NR==1{print $2}\u0026#39;) if [ ! ${id} ] then echo \u0026#34;项目未启动!\u0026#34; else sudo kill -9 $id echo \u0026#34;项目已关闭!\u0026#34; fi sudo chmod +x ./main sudo nohup ./main \u0026gt;\u0026gt; web.log 2\u0026gt;\u0026amp;1 \u0026amp; echo $(sudo lsof -i:7091|grep main|awk \u0026#39;NR==1{print $2}\u0026#39;) egg-server.sh 1 2 3 4 5 6 7 cd /opt/egg-server; pid=$(ps -ef | grep \u0026#34;egg\u0026#34; | grep -v grep | awk \u0026#39;{print $2}\u0026#39; |tail -n 3 | head -n 1); kill ${pid} sudo git pull origin master sudo npm i nohup npm run dev \u0026amp; exit 0 ","date":"2022-04-19T15:55:42+08:00","permalink":"https://petrichor.net.cn/p/shell-scripts/","title":"常用 shell 脚本"},{"content":"如何安装适用于 Linux 的 Windows 子系统。\n1 wsl --install 正在安装: 虚拟机平台 已安装 虚拟机平台。 正在安装: 适用于 Linux 的 Windows 子系统 已安装 适用于 Linux 的 Windows 子系统。 正在下载: WSL 内核 [============= 22.8% ]\n1 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 部署映像服务和管理工具 版本: 10.0.22000.1\n映像版本: 10.0.22000.556\n启用一个或多个功能 [==========================100.0%==========================] 操作成功完成。\n1 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 部署映像服务和管理工具 版本: 10.0.22000.1\n映像版本: 10.0.22000.556\n启用一个或多个功能 [==========================100.0%==========================] 操作成功完成。\n指定要安装的子系统的版本\n1 wsl --install -d Ubuntu 参考链接\nhttps://ruihusky.github.io/ruihusky/posts/2020-12-11_wsl2-net-config/ https://logi.im/script/achieving-access-to-files-and-resources-on-the-network-between-win10-and-wsl2.html https://hangzhi.github.io/2021/06/24/wsl2GolandThanosDev/ ","date":"2022-04-12T22:00:47+08:00","permalink":"https://petrichor.net.cn/p/wsl2/","title":"Wsl2"},{"content":"本文将记录如何使用 Drone 自动部署 Go 应用。\n介绍 Drone CI 官网介绍：\nAutomate Software Build and Testing\nDrone is a self-service Continuous Delivery platform for busy development teams.\nGitea 官网介绍：\nGitea 是一个自己托管的Git服务程序。他和GitHub, Bitbucket or Gitlab等比较类似。他是从 Gogs 发展而来，不过我们已经Fork并且命名为Gitea。\nGitea的首要目标是创建一个极易安装，运行非常快速，安装和使用体验良好的自建 Git 服务。我们采用Go作为后端语言，这使我们只要生成一个可执行程序即可。并且他还支持跨平台，支持 Linux, macOS 和 Windows 以及各种架构，除了x86，amd64，还包括 ARM 和 PowerPC。\n自动部署流程 项目中写入 .drone.yml 配置文件，push 到 gitea 中 gitea 通过钩子函数告诉 drone drone 读取配置文件，通过 drone-runner-* 部署项目 安装 安装 drone-server 和 drone-runner-docker 这里使用 docker-compose 安装。\n在 docker-compose 所在目录使用 docker-compose up -d 安装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 version: \u0026#39;3\u0026#39; services: # 容器名称 drone-server: # 构建所使用的镜像 image: drone/drone:1 # 映射容器内80端口到宿主机的7079端口 ports: - 7079:80 # 映射容器内/data目录到宿主机的/data/drone目录 volumes: - /data/drone:/data # 容器随docker自动启动 restart: always environment: # Gitea 服务器地址 - DRONE_GITEA_SERVER=http://ip:port # Gitea OAuth2客户端ID - DRONE_GITEA_CLIENT_ID=XXX # Gitea OAuth2客户端密钥 - DRONE_GITEA_CLIENT_SECRET=yyy #- DRONE_GIT_ALWAYS_AUTH= # drone的共享密钥 - DRONE_RPC_SECRET=drone_rpc_secret # drone的主机名 - DRONE_SERVER_HOST=ip:port # 外部协议方案 - DRONE_SERVER_PROTO=http # 创建管理员账户，这里对应为gitea的用户名 - DRONE_USER_CREATE=username:admin,admin:true drone-runner-docker: image: drone/drone-runner-docker:1 ports: - 7080:3000 restart: always depends_on: - drone-server volumes: - /var/run/docker.sock:/var/run/docker.sock environment: # 用于连接到Drone服务器的协议。该值必须是http或https。 - DRONE_RPC_PROTO=http # 用于连接到Drone服务器的主机名 - DRONE_RPC_HOST=ip:port # Drone服务器进行身份验证的共享密钥，和上面设置一样 - DRONE_RPC_SECRET=drone_rpc_secret # 限制运行程序可以执行的并发管道数。运行程序默认情况下执行2个并发管道。 - DRONE_RUNNER_CAPACITY=2 # docker runner 名称 - DRONE_RUNNER_NAME=drone-runner 安装 drone-runner-exec 下载 1 2 curl -L https://github.com/drone-runners/drone-runner-exec/releases/latest/download/drone_runner_exec_linux_amd64.tar.gz | tar zx sudo install -t /usr/local/bin drone-runner-exec 配置 配置文件为 /etc/drone-runner-exec/config ，需要手动创建并写入一下内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 用于连接到Drone服务器的协议。该值必须是http或https DRONE_RPC_PROTO=http # 用于连接到Drone服务器的主机名 DRONE_RPC_HOST=ip:port # Drone服务器进行身份验证的共享密钥，和上面设置一样 DRONE_RPC_SECRET=drone_rpc_secret # log 存储目录，需要自行建立 DRONE_LOG_FILE=/opt/drone/drone-runner-exec/log.txt # 限制运行程序可以执行的并发管道数。运行程序默认情况下执行2个并发管道 # limits the number of concurrent pipelines that a runner can execute DRONE_RUNNER_CAPACITY=2 DRONE_RUNNER_NAME=drone-runner-exec DRONE_RUNNER_PATH=/bin:/usr/local/go/bin:/usr/local/bin:/usr/bin:/usr/sbin:/sbin # sets the PATH variable for all pipeline steps # 日志追踪 DRONE_TRACE=true 启动 1 2 3 drone-runner-exec service install drone-runner-exec service start tail /opt/drone/drone-runner-exec/log.txt ➜ drone-runner-exec drone-runner-exec service install\nread configuration /home/ubuntu/.drone-runner-exec/config\ninstalling service drone-runner-exec\ndrone-runner-exec: error: cannot read configuration, try \u0026ndash;help\n\u0026hellip;\n项目配置文件 .drone.yml 在宿主机执行命令，编译并运行 如果项目根目录中有 .drone.yml 文件，drone 就可以读取文件中的内容，从而进行自动部署。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 kind: pipeline # 对象类型，有 pipeline、secret 和 signature 等类型 type: exec # 流水线类型，有 docker、kubernetes、exec、ssh 等类型 name: drone-golang-example platform: os: linux arch: amd64 steps: - name: test \u0026amp; build environment: GOOS: linux GOARCH: amd64 CGO_ENABLED: 0 commands: - whoami - echo \u0026#34;==== test ====\u0026#34; - go test - echo \u0026#34;==== build ====\u0026#34; - go build -o server - name: copy commands: - cp -rf ./server /opt/drone-golang-example/server - chown ubuntu:ubuntu /opt/drone-golang-example/server - chmod 755 /opt/drone-golang-example/server - name: stop commands: - sh scripts/stop.sh - name: run commands: - echo \u0026#34;==== run ====\u0026#34; - cd /opt/drone-golang-example - nohup ./server 2\u0026gt;\u0026amp;1 \u0026gt; web.log \u0026amp; - echo \u0026#34;running\u0026#34; - name: notify commands: - echo \u0026#34;failure\u0026#34; when: status: - failure trigger: branch: - main event: - push 其中 stop.sh 内容为：\n1 2 3 4 5 6 7 8 9 10 11 #! /bin/sh # NR==1 第一行 # print $2 输出第二个参数 id=$(sudo lsof -i:7007|grep drone-golang-example|awk \u0026#39;NR==1{print $2}\u0026#39;) if [ ! ${id} ] then echo \u0026#34;项目未启动\u0026#34; else sudo kill -9 $id fi 在 Docker 中运行 TODO\n注意 Pending 没有对应的 runner，需要哪个就安装哪个，对应 .drone.yml 中的 type，本文需要安装 ⬆️drone-runner-exec 。\nfatal: could not read Username for 'http://ip:port': terminal prompts disabled 需要用户名等，这里发现仓库设置为了私有，改为公开，不再报此错误。\n若需要使用私有仓库，参考一下这篇文章。\ncommand not found 如：\ngo: command not found scripts/stop.sh: line 3: grep: command not found 在配置文件中修改配置项 DRONE_RUNNER_PATH ，需要的命令在哪个路径就加什么。\n或者也可以将 .drone.yml 中的 go 改为绝对路径，比如我这里是 /usr/local/go/bin/go (不推荐)。\nNo such process 旧：脚本使用 ps 查找进程\n第一次运行时，并没有已经运行的进程去停止，可以先把 .drone.yml 中 stop 这一步去掉。\n新：脚本使用 lsof 查找进程\n未启动会输出项目未启动。\n某一阶段(run)一直显示 Running 不停止 。。。\nReference https://fix.moe/post/start-drone-ci https://docs.drone.io ","date":"2022-04-08T15:16:18+08:00","permalink":"https://petrichor.net.cn/p/drone-gitea-golang/","title":"使用 Drone CI 自动部署 Go 应用"},{"content":"npm 与 yarn 配置。\n更改默认目录 npm 缓存默认在 C 盘，这会占用 C 盘大量空间，咱们把它改为其他目录。\n删除缓存 在修改之前，先把之前的缓存删除。当然也可以找到对应的文件夹手动删除。\nnpm 缓存默认使用 ~\\AppData\\Local\\npm-cache\\_cacache 目录。\n1 npm cache verify Cache verified and compressed (~\\AppData\\Local\\npm-cache_cacache) Content verified: 123 (6009783 bytes) Index entries: 123 Finished in 1.58s\n使用以下命令清空缓存。\n1 npm cache clean --force 可以看到，缓存目录已经发生了变化，_cacache 目录已经没了。它会报一个警告，可以不用管。\nnpm WARN using \u0026ndash;force Recommended protections disabled.\n全局配置 我这里 Node.js 安装路径是 D:\\Software\\nodejs 。\n设置 npm、yarn 包全局下载路径 1 npm config set prefix \u0026#34;D:\\Software\\nodejs\\node_global\u0026#34; 1 yarn config set prefix \u0026#34;D:\\Software\\Yarn\\global\u0026#34; 设置 npm、yarn 缓存路径 1 npm config set cache \u0026#34;D:\\Software\\nodejs\\node_cache\u0026#34; 1 yarn config set cache-folder \u0026#34;D:\\Software\\Yarn\\cache\u0026#34; 下载一下试一试， npm install hexo-cli -g ，发现报错。\nnpm ERR! code EPERM npm ERR! syscall mkdir npm ERR! path D:\\Software\\nodejs\\node_cache_cacache npm ERR! errno EPERM npm ERR! FetchError: Invalid response body while trying to fetch https://registry.npmjs.org/hexo-cli: EPERM: operation not permitted, mkdir \u0026lsquo;D:\\Software\\nodejs\\node_cache_cacache\u0026rsquo;\n权限问题，把以上两个文件夹设置为可以修改与写入即可。\n修改环境变量 最后记得把 npm 的环境变量改一下，改成 node_global 这个路径。\n换源 改为淘宝源。\nnpm 换源 1 npm config set registry https://registry.npm.taobao.org yarn 换源 1 yarn config set registry https://registry.npm.taobao.org/ Reference https://www.cnblogs.com/hellomrr/p/13237653.html ","date":"2022-03-31T11:21:59+08:00","permalink":"https://petrichor.net.cn/p/node-config/","title":"npm 与 yarn 更改默认目录并换源"},{"content":"若未设置 live 参数，则直接调用嵌入的文件；\n若设置了 live，调用外部文件，这样只修改这些静态文件不需要重新编译。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var ( //go:embed static Static embed.FS ) func GetFileSystem() http.FileSystem { if len(os.Args) \u0026gt; 1 \u0026amp;\u0026amp; os.Args[1] == \u0026#34;live\u0026#34; { log.Println(\u0026#34;using live mode\u0026#34;) return http.FS(os.DirFS(\u0026#34;static\u0026#34;)) } log.Println(\u0026#34;using embed mode\u0026#34;) fsys, err := fs.Sub(Static, \u0026#34;static\u0026#34;) if err != nil { panic(err) } return http.FS(fsys) } ","date":"2022-03-02T16:04:50+08:00","permalink":"https://petrichor.net.cn/p/go-embed-gin/","title":"『Go』静态文件嵌入"},{"content":"限流是高并发服务中非常有效和常用的解决方案，用来限制请求速率，避免服务过载。\n常见的限流算法有很多种，如固定时间窗口、滑动时间窗口、漏桶、令牌桶等。\n固定时间窗口算法 这是一种比较简单的限流算法，一定时间内，对请求进行计数，达到阈值则暂不接受请求，时间到达临界值则重新计数。\n比如我们要限制一分钟接受请求 60 次，从第一次收到请求起开始计时，在接下来的一分钟内，每收到一个请求计数就 +1 ，超过限制的 60 次后就开始拒绝请求，直到一分钟计时结束，重新开始计数。\n这种算法优点是简单，缺点也很明显，我们没办法控制接收到的请求是按时间均匀分布的。\n如果第一分钟的前半分钟只收到了 10 次请求，后半分钟收到了 50 次；第二分钟反过来，前半分钟收到了 50 次，后半分钟收到了 10 次。很明显，中间的两个半分钟（也就是一分钟）内一共收到了 100 次请求，超出了限制，这不是我们想要的。\n还有一种情况，前十秒我们收到的请求数达到了最大数，后面五十秒的请求就只能全部拒绝，这种现象也叫**“突刺现象”**。\n{% note info 突刺现象 %}\n指在一定时间内的一小段时间内就用完了所有资源，后面大部分时间中无资源可用。\n{% endnote %}\n滑动时间窗口算法(Sliding Window) 针对固定时间算法会在临界点存在瞬间大流量冲击的场景，滑动时间窗口计数器算法应运而生。\n学过计算机网络的同学，应该都记得滑动时间窗口协议。这个协议是 TCP 协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。这里的滑动时间窗口算法原理类似，只是应用场景不同。\n它将时间窗口划分为更小的时间片段，每过一个时间片段，我们的时间窗口就会往右滑动一格，每个时间片段都有独立的计数器。我们在计算整个时间窗口内的请求总数时会累加所有的时间片段内的计数器。时间窗口划分的越细，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。\n漏桶算法(Leaky Bucket) 漏桶算法控制输出速率而不管输入数据的突发性，当输入空闲的时候，该算法不执行任何动作。\n就像一个漏水的桶，系统收到的请求就是流入桶里的水，处理请求就是让水从下面流出来，在这里输出的速率是恒定的。漏桶算法通过控制流量输出速率，平滑网络上的突发流量，实现流量整形，以保证网络服务的稳定。\n令牌桶算法(Token Bucket) 系统以一定的速度向令牌桶中放置令牌，当接收到请求时，向令牌桶中申请令牌，如果能够申请到，请求正常进行，反之不响应请求。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。\n其实 golang 标准库中就有限流算法的实现，即 golang.org/x/time/rate 库，该限流器就是基于令牌桶实现的。\nReference 漏桶算法 | 百度百科 令牌桶算法 | 百度百科 ","date":"2022-02-05T09:12:20+08:00","permalink":"https://petrichor.net.cn/p/rate-limiting/","title":"限流算法"},{"content":"Systemd 统一管理所有 Unit 的启动日志。带来的好处就是可以只用 journalctl 一个命令，查看到所有日志（内核日志和应用日志）。\nhttps://www.linuxcool.com/journalctl\n语法格式： journalctl [参数]\n常用参数：\n-k 查看内核日志 -b 查看系统本次启动的日志 -u 查看指定服务的日志 -n 指定日志条数 -f 追踪日志 \u0026ndash;disk-usage 查看当前日志占用磁盘的空间的总大小 参考实例\n查看所有日志：\n1 [root@linux ~]# journalctl 查看内核日志：\n1 [root@linux ~]# journalctl -k 查看系统本次启动的日志：\n1 [root@linux ~]# journalctl -b 查看httpd的日志：\n1 [root@linux ~]# journalctl -u httpd 查看最近发生的20条日志：\n1 [root@linux ~]# journalctl -n 20 追踪日志：\n1 [root@linux ~]# journalctl -f ","date":"2022-02-04T16:57:57+08:00","permalink":"https://petrichor.net.cn/p/journalctl/","title":"journalctl - 查看日志"},{"content":"函数的不定参 新亮笔记、gRPC、kratos、progressbar 等项目都大量用到了这个写法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type Logger struct { // ... } type Option func(*option) type option struct { level Level fields map[string]string file io.Writer timeLayout string disableConsole bool } func NewLogger(opts ...Option) (*Logger, error) { logger := new(option) for _, f := range opts { f(opt) } // ... logger := XXX return logger, nil } func WithErrorLevel() Option { return func(opt *option) { opt.level = ErrorLevel } } func WithField(key, value string) Option { return func(opt *option) { opt.fields[key] = value } } 使用\n1 2 3 logger, err := NewLogger( WithField(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;), ) 这样写有一个好处，后续新增其他参数时，也很方便配置。\n接口相关 1 2 3 4 5 6 7 8 9 10 var _ Student = (*student)(nil) // 一 type Student interface { i() // 二 Study() } type student struct { Name string } 第一种 1 var _ Student = (*student)(nil) 强制 *student 去实现 Student 接口，编译器会进行检查。\n如果没有实现呢，编译器就会报错：\npanic: runtime error: invalid memory address or nil pointer dereference\n如果去掉那一行强制检查，就不会报错了。\n第二种 1 i() 这也是一种很巧妙的写法，强制 Student 接口中的方法只能在本包中实现，因为有这个首字母小写的方法，其他包是不能实现的。这里的方法名只要是首字母小写就可以。\n","date":"2022-02-02T14:59:25+08:00","permalink":"https://petrichor.net.cn/p/go-some-interesting-code/","title":"『Go』一些有意思的代码写法"},{"content":"遍历指定文件夹下的所有 .png 文件，并转换为 .webp 格式 1 2 3 4 @echo off for %%a in (D:\\Blog\\source\\assets\\*.png) do (cwebp.exe -q 80 %%a -o %%~na.webp) pause 遍历当前目录所有子文件夹下的所有 .png 文件，并转换为 .webp 格式 1 2 3 4 5 6 7 8 @echo off set DIR=\u0026#34;%cd%\u0026#34; echo DIR=%DIR% for /d %%d in (*) do ( echo %%d for %%a in (%%d\\*.png) do (cwebp.exe -q 80 %%a -o %%d\\%%~na.webp) ) pause 其中 %%~na 是取 %%a 这个文件的文件名（去掉路径且不带后缀）\n本来是用 gulp-webp 的，结果一直报错而且乱码，找不到原因，只能手动转了（破案了，这个库我下载之后找不到对应的二进制文件，把原先下载的复制过去就好了）。\n","date":"2021-12-26T23:00:39+08:00","permalink":"https://petrichor.net.cn/p/webp-bat/","title":"Webp Bat"},{"content":"我想定义一个像这样的常量：\n1 2 3 4 const Code = map[string]interface{}{ \u0026#34;a\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;456\u0026#34;, } 发现报错了：\nConst initializer \u0026lsquo;map[string]interface{}{\u0026hellip;}\u0026rsquo; is not a constant\n而当我这样定义时：\n1 2 3 4 5 6 7 const Len = len(\u0026#34;qwe\u0026#34;) const Len2 = length(\u0026#34;qwe\u0026#34;) //length(\u0026#34;qwe\u0026#34;) (value of type int) is not constant func length(a string) int { return len(a) } 发现 Len 不会报错，而 Len2 却会报错。那 Golang 中什么才可以定义为常量呢？\n原来 Golang 中的常量是编译期常量，在编译时就会完全确定取值，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型\n所以不能将函数的返回值赋给常量(函数调用发生在运行时期)，文章开头的 map 也不能定义为常量\n相比之下，Java 中声明为 final 类型的基本类型或声明为 String 类型并直接赋值(非运算)的变量和 JavaScript 中的 const 代表的是一次性赋值的变量，本质上还是变量，只是不允许再做修改\n{% note tip tip %} 这里可以用锁 {% endnote %}\n可是 len() 为什么可以呢，难道这个函数就不是函数了吗？\n一番搜索后我看到了一个词：内联函数\n内联函数 什么是内联函数\n{% note info 内联函数 %}\n在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）。\n引自内联函数_百度百科\n{% endnote %}\n原来 len() 是一个内联函数，既然他是编译时期展开函数，那就没问题了\n学过 C 语言的应该对内联函数不陌生，在 C 语言中有一个关键字 inline ， 使用 inline 修饰的函数就是内联函数。比如：\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; inline int add(int a, int b) { return a + b; } int main() { printf(\u0026#34;%d\u0026#34;, add(1, 2)); // 3 } 这段代码中 int add(int a, int b) 使用了 inline 进行修饰，那代码在执行的时候就会变成下面这样：\n1 printf(\u0026#34;%d\u0026#34;, 1 + 2); 这样可以避免频繁调用函数时栈内存重复开辟所带来的消耗，一般用于这种能够快速执行的短小的函数，因为在这种情况下函数调用的时间消耗显得更为突出\n我们再来运行一下这段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; const Len = len(\u0026#34;qwe\u0026#34;) const hello = \u0026#34;Hello World\u0026#34; func length(a string) int { return len(a) } func main() { fmt.Println(length(\u0026#34;qwe\u0026#34;)) fmt.Println(hello) } 执行 go run --gcflags=-m .\\main.go ，输出如下：\n# command-line-arguments .\\main.go:8:6: can inline length .\\main.go:13:20: inlining call to length .\\main.go:13:13: inlining call to fmt.Println .\\main.go:14:13: inlining call to fmt.Println .\\main.go:8:13: a does not escape .\\main.go:13:20: length(\u0026ldquo;qwe\u0026rdquo;) escapes to heap .\\main.go:13:13: []interface {}{\u0026hellip;} does not escape .\\main.go:14:13: hello escapes to heap .\\main.go:14:13: []interface {}{\u0026hellip;} does not escape :1: .this does not escape :1: .this does not escape 3 Hello World\n可以看到，length 可以作为内联函数，main 不可以，而 fmt.Println 也是一个内联函数。我们再来这样跑一下：go run --gcflags=\u0026quot;-m -m\u0026quot; .\\main.go ，注意中间加了一个 -m ，得到输出如下，可以看到更详细地信息，也可以看到 fmt.Println 与 length 都被展开为了怎样的形式：\n{% fold %}\n#command-line-arguments .\\main.go:8:6: can inline length with cost 3 as: func(string) int { return len(a) } .\\main.go:12:6: cannot inline main: function too complex: cost 157 exceeds budget 80 .\\main.go:13:20: inlining call to length func(string) int { return len(a) } .\\main.go:13:13: inlining call to fmt.Println func(\u0026hellip;interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = ; var fmt..autotmp_4 error; fmt..autotmp_4 = ; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a\u0026hellip;); return fmt..autotmp_3, fmt..autotmp_4 } .\\main.go:14:13: inlining call to fmt.Println func(\u0026hellip;interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = ; var fmt..autotmp_4 error; fmt..autotmp_4 = ; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a\u0026hellip;); return fmt..autotmp_3, fmt..autotmp_4 } .\\main.go:8:13: a does not escape .\\main.go:14:13: hello escapes to heap: .\\main.go:14:13: flow: ~arg0 = \u0026amp;{storage for hello}: .\\main.go:14:13: from hello (spill) at .\\main.go:14:13 .\\main.go:14:13: from ~arg0 := hello (assign-pair) at .\\main.go:14:13 .\\main.go:14:13: flow: {storage for []interface {}{\u0026hellip;}} = ~arg0: .\\main.go:14:13: from []interface {}{\u0026hellip;} (slice-literal-element) at .\\main.go:14:13 .\\main.go:14:13: flow: fmt.a = \u0026amp;{storage for []interface {}{\u0026hellip;}}: .\\main.go:14:13: from []interface {}{\u0026hellip;} (spill) at .\\main.go:14:13 .\\main.go:14:13: from fmt.a = []interface {}{\u0026hellip;} (assign) at .\\main.go:14:13 .\\main.go:14:13: flow: {heap} = *fmt.a: .\\main.go:14:13: from fmt.Fprintln(io.Writer(os.Stdout), fmt.a\u0026hellip;) (call parameter) at .\\main.go:14:13 .\\main.go:13:20: length(\u0026ldquo;qwe\u0026rdquo;) escapes to heap: .\\main.go:13:20: flow: ~arg0 = \u0026amp;{storage for length(\u0026ldquo;qwe\u0026rdquo;)}: .\\main.go:13:20: from length(\u0026ldquo;qwe\u0026rdquo;) (spill) at .\\main.go:13:20 .\\main.go:13:20: from ~arg0 := length(\u0026ldquo;qwe\u0026rdquo;) (assign-pair) at .\\main.go:13:13 .\\main.go:13:20: flow: {storage for []interface {}{\u0026hellip;}} = ~arg0: .\\main.go:13:20: from []interface {}{\u0026hellip;} (slice-literal-element) at .\\main.go:13:13 .\\main.go:13:20: flow: fmt.a = \u0026amp;{storage for []interface {}{\u0026hellip;}}: .\\main.go:13:20: from []interface {}{\u0026hellip;} (spill) at .\\main.go:13:13 .\\main.go:13:20: from fmt.a = []interface {}{\u0026hellip;} (assign) at .\\main.go:13:13 .\\main.go:13:20: flow: {heap} = *fmt.a: .\\main.go:13:20: from fmt.Fprintln(io.Writer(os.Stdout), fmt.a\u0026hellip;) (call parameter) at .\\main.go:13:13 .\\main.go:13:20: length(\u0026ldquo;qwe\u0026rdquo;) escapes to heap .\\main.go:13:13: []interface {}{\u0026hellip;} does not escape .\\main.go:14:13: hello escapes to heap .\\main.go:14:13: []interface {}{\u0026hellip;} does not escape :1: .this does not escape :1: .this does not escape 3 Hello World\n{% endfold %}\n无类型常量 1 2 const hello = \u0026#34;Hello World\u0026#34; //const hello untyped string = \u0026#34;Hello World\u0026#34; 我们发现，当我们这样定义一个字符串常量时，它的类型是 untyped string\n原来 Go 中有六种未明确类型的常量类型，分别是\n无类型的布尔型 无类型的整形 无类型的字符型 无类型的浮点型 无类型的复数 无类型的字符串 编译器会为这些没有明确基础类型的常量提供比基础类型更高精度的算术运算，赋值给特定类型时会有影响\n","date":"2021-11-12T14:03:19+08:00","permalink":"https://petrichor.net.cn/p/go-const-inline/","title":"『Go』const常量与内联函数"},{"content":" 本文摘自正则表达式-语法|菜鸟教程\n普通字符 字符 描述 [ABC] 匹配所有[]中的字符 [^ABC] 匹配除了[]中字符的所有字符 [A-Z] 匹配一个区间中的所有字符，例子表示匹配所有大写字母 . 匹配除换行符(\\n、\\r)之外的任何单个字符，相当于[^\\n\\r] [\\s\\S] 匹配所有，\\s是所有空白符，包括换行；\\S是所有非空白符，不包括换行 \\w 匹配字母、数字、下划线，等价于[A-Za-z0-9_] 非打印字符 字符 描述 \\cx 匹配由 x 指明的控制字符。例如，\\cM匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 \u0026lsquo;c\u0026rsquo; 字符 \\f 匹配一个换页符，等价于 \\x0c 和 \\cL \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ \\r 匹配一个回车符。等价于 \\x0d 和 \\cM \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v] \\t 匹配一个制表符。等价于 \\x09 和 \\cI \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK 特殊字符 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 \\n 或 \\r。要匹配 $ 字符本身，请使用 \\$ ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\) * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\* + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+ . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. [ 标记一个中括号表达式的开始。要匹配 [，请使用 \\[ ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\? \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n 匹配字符 n。\\n 匹配换行符。序列 \\\\ 匹配 \\，而 \\( 则匹配 ( ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \\^ { 标记限定符表达式的开始。要匹配 {，请使用 \\{ 竖线 指明两项之间的一个选择。要匹配 \u0026lsquo;竖线\u0026rsquo;，请使用 \\ + 竖线（竖线是 markdown 中表格的一部分，会导致表格错位，暂时没找到解决办法，用汉语取代） 限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。\n正则表达式的限定符有：\n字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \u0026ldquo;z\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;。* 等价于{0,} + 匹配前面的子表达式一次或多次。例如，\u0026lsquo;zo+\u0026rsquo; 能匹配 \u0026ldquo;zo\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;，但不能匹配 \u0026ldquo;z\u0026rdquo;。+ 等价于 {1,} ? 匹配前面的子表达式零次或一次。例如，\u0026ldquo;do(es)?\u0026rdquo; 可以匹配 \u0026ldquo;do\u0026rdquo; 、 \u0026ldquo;does\u0026rdquo; 中的 \u0026ldquo;does\u0026rdquo; 、 \u0026ldquo;doxy\u0026rdquo; 中的 \u0026ldquo;do\u0026rdquo; 。? 等价于 {0,1} {n} n 是一个非负整数。匹配确定的 n 次。例如，\u0026lsquo;o{2}\u0026rsquo; 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 \u0026lsquo;o\u0026rsquo;，但是能匹配 \u0026ldquo;food\u0026rdquo; 中的两个 o {n,} n 是一个非负整数。至少匹配n 次。例如，\u0026lsquo;o{2,}\u0026rsquo; 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 \u0026lsquo;o\u0026rsquo;，但能匹配 \u0026ldquo;foooood\u0026rdquo; 中的所有 o。\u0026lsquo;o{1,}\u0026rsquo; 等价于 \u0026lsquo;o+\u0026rsquo;。\u0026lsquo;o{0,}\u0026rsquo; 则等价于 \u0026lsquo;o*\u0026rsquo; {n,m} m 和 n 均为非负整数，其中n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次。例如，\u0026ldquo;o{1,3}\u0026rdquo; 将匹配 \u0026ldquo;fooooood\u0026rdquo; 中的前三个 o。\u0026lsquo;o{0,1}\u0026rsquo; 等价于 \u0026lsquo;o?\u0026rsquo;。请注意在逗号和两个数之间不能有空格 ","date":"2021-10-31T15:56:48+08:00","permalink":"https://petrichor.net.cn/p/regexp/","title":"正则表达式(regular expression)"},{"content":" Docker 什么是 Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 或 Windows 操作系统的机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。\n安装 官方文档 - Install Docker Engine on Ubuntu\n删除旧版本 1 for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done apt 安装 设置 Docker 的 apt 存储库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 添加 Docker 官方 GPG key: sudo apt-get update sudo apt-get install ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg # 添加 apt 源: echo \\ \u0026#34;deb [arch=\u0026#34;$(dpkg --print-architecture)\u0026#34; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \u0026#34;$(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;)\u0026#34; stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 更新 sudo apt-get update 安装\n1 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 下载 hello-world 镜像验证\n1 sudo docker run hello-world 脚本一键安装 1 2 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 将当前用户加入 docker 组： #Got permission denied\n使用 基本命令 1 2 3 4 5 6 7 8 9 # 显示 Docker 版本信息 sudo docker version # 显示整个系统的信息 sudo docker info # 命令帮助 sudo docker help sudo docker COMMAND --help docker 命令帮助\r``` Usage: docker [OPTIONS] COMMAND A self-sufficient runtime for containers Options: ​ --config string Location of client config files (default \"/home/ubuntu/.docker\") -c, --context string Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with \"docker context use\") -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (\"debug\"|\"info\"|\"warn\"|\"error\"|\"fatal\") (default \"info\") ​ --tls Use TLS; implied by --tlsverify ​ --tlscacert string Trust certs signed only by this CA (default \"/home/ubuntu/.docker/ca.pem\") ​ --tlscert string Path to TLS certificate file (default \"/home/ubuntu/.docker/cert.pem\") ​ --tlskey string Path to TLS key file (default \"/home/ubuntu/.docker/key.pem\") ​ --tlsverify Use TLS and verify the remote ​ -v, --version Print version information and quit Management Commands: app* Docker App (Docker Inc., v0.9.1-beta3) builder Manage builds buildx* Build with BuildKit (Docker Inc., v0.5.1-docker) config Manage Docker configs container Manage containers context Manage contexts image Manage images manifest Manage Docker image manifests and manifest lists network Manage networks node Manage Swarm nodes plugin Manage plugins scan* Docker Scan (Docker Inc., v0.7.0) secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes Run 'docker COMMAND --help' for more information on a command. To get more help with docker, check out our guides at https://docs.docker.com/go/guides/ ``` 镜像相关 1 docker images --help docker images 命令帮助\r``` Usage: docker images [OPTIONS] [REPOSITORY[:TAG]] List images Options: -a, --all Show all images (default hides intermediate images) --digests Show digests -f, --filter filter Filter output based on conditions provided --format string Pretty-print images using a Go template --no-trunc Don't truncate output -q, --quiet Only show image IDs ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 查找镜像 docker search golang # 拉取镜像 docker pull golang docker pull golang:latest # 指定版本 # 查看已安装镜像 docker images # 删除镜像 docker rmi golang # 通过镜像名 docker rmi 0ac33e5f5afa # 通过镜像 ID # 删除全部镜像 docker rmi $(docker images -qa) # 参数 q(quiet)：只显示镜像 ID # 参数 a(all)：显示所有镜像(包括中间镜像) 容器相关 docker run - 在新容器中运行\n以交互模式在后台启动一个名为 grafana 的容器，并分配 tty，使用宿主机网络，永远会重启。\n1 docker run -itd --net=host --restart=always --name=grafana grafana/grafana docker run 具体选项\r| 选项 | 说明 | | ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | -d, --detach=false | 指定容器运行于前台还是后台，默认为 false。 | | -i, --interactive=false | 打开 STDIN，用于控制台交互。 | | -t, --tty=false | 分配 tty 设备，可以支持终端登录，默认为 false。 | | -u, --user=\"\" | 指定容器的用户。 | | -a, --attach=[] | 登录容器（必须是以 docker run -d 启动的容器）。 | | -w, --workdir=\"\" | 指定容器的工作目录。 | | -c, --cpu-shares=0 | 设置容器 CPU 权重，在 CPU 共享场景使用。 | | -e, --env=[] | 指定环境变量，容器中可以使用该环境变量。 | | -m, --memory=\"\" | 指定容器的内存上限。 | | -P, --publish-all=false | 指定容器暴露的端口。 | | -p, --publish=[] | 指定容器暴露的端口。 | | -h, --hostname=\"\" | 指定容器的主机名。 | | -v, --volume=[] | 给容器挂载存储卷，挂载到容器的某个目录。 | | –volumes-from=[] | 给容器挂载其他容器上的卷，挂载到容器的某个目录。 | | –cap-add=[] | 添加权限。 | | –cap-drop=[] | 删除权限。 | | –cidfile=\"\" | 运行容器后，在指定文件中写入容器 PID 值，一种典型的监控系统用法。 | | –cpuset=\"\" | 设置容器可以使用哪些 CPU，此参数可以用来容器独占 CPU。 | | –device=[] | 添加主机设备给容器，相当于设备直通。 | | –dns=[] | 指定容器的 dns 服务器。 | | –dns-search=[] | 指定容器的 dns 搜索域名，写入到容器的 /etc/resolv.conf 文件。 | | –entrypoint=\"\" | 覆盖 image 的入口点。 | | –env-file=[] | 指定环境变量文件，文件格式为每行一个环境变量。 | | –expose=[] | 指定容器暴露的端口，即修改镜像的暴露端口。 | | –link=[] | 指定容器间的关联，使用其他容器的 IP、env 等信息。 | | –lxc-conf=[] | 指定容器的配置文件，只有在指定 --exec-driver=lxc 时使用。 | | –name=\"\" | 指定容器名字，后续可以通过名字进行容器管理，links 特性需要使用名字。 | | –net=“bridge” | 器网络设置： 1. bridge 使用 docker daemon 指定的网桥。 2. host //容器使用主机的网络。 3. container:NAME_or_ID \u003e//使用其他容器的网路，共享 IP 和 PORT 等网络资源。 4. none 容器使用自己的网络（类似–net=bridge），但是不进行配置。 | | –privileged=false | 指定容器是否为特权容器，特权容器拥有所有的 capabilities。 | | –restart=“no” | 指定容器停止后的重启策略: (1) no，容器退出时不重启 (2) on-failure，容器故障退出（返回值非零）时重启 (3) on-failure:3，同上，最多重启 3 次 (4) always，容器退出时总是重启 | | –rm=false | 指定容器停止后自动删除容器(不支持以 docker run -d 启动的容器)。 | | –sig-proxy=true | 设置由代理接受并处理信号，但是 SIGCHLD、SIGSTOP 和 SIGKILL 不能被代理。 | Dockerfile 什么是 Dockerfile？\n{% cq %}Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。{% endcq %}\n{% note caution caution %} Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。 {% endnote %}\nDocker Compose Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\nCompose 使用有三个步骤：\n使用 Dockerfile 定义应用程序的环境 使用 docker-compose.yml 定义构成应用程序的服务，这样他们可以在隔离环境中一起运行 最后，执行 docker-compose up 命令来启动并运行整个应用程序 看一个 docker-compose.yml 文件示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 version: \u0026#39;3\u0026#39; services: web: container_name: dockerdev # 容器名 build: . # 在本目录构建 ports: - \u0026#34;15000:5000\u0026#34; # 将容器内的 5000 端口映射到宿主机的 15000 端口 environment: # 环境变量 ACCESS_KEY: admin volumes: # 挂载数据卷（冒号前为宿主机目录，后为容器内目录） - .:/code - logvolume01:/var/log links: # 链接其他容器 - redis redis: image: redis volumes: # 数据卷 logvolume01: {} 1 2 docker-compose up docker-compose up -d # 后台启动 容器备份 备份 1 docker ps -a 备份 grafana 容器，容器名为 grafana，容器 id 为 ab8adb9ae93d，执行如下命令：\n1 docker commit -p ab8adb9ae93d grafana-backup 1 docker images 此时已经有了一个名为 grafana-backup 的镜像。\n1 docker save grafana-backup \u0026gt; /home/ubuntu/Download/grafana-backup.tar 恢复 将备份文件上传到需要使用的服务器\n导入\n1 2 docker load \u0026lt; /home/ubuntu/Download/grafana-backup.tar docker images 可以看到一个名为 grafana-backup 的镜像，导入成功。\nportainer 可视化 1 docker pull portainer/portainer-ce 1 docker volume create portainer_data 1 2 3 4 5 docker run -d -p 8000:8000 -p 9000:9000 \\ --name=portainer --restart=always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v portainer_data:/data \\ portainer/portainer-ce 注意 Got permission denied Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json: dial unix /var/run/docker.sock: connect: permission denied\ndocker 进程使用 Unix Socket 而不是 TCP 端口。而默认情况下，Unix socket 属于 root 用户，需要 root 权限才能访问。\nManage Docker as a non-root user\nThe Docker daemon binds to a Unix socket, not a TCP port. By default it\u0026rsquo;s the root user that owns the Unix socket, and other users can only access it using sudo. The Docker daemon always runs as the root user.\nIf you don\u0026rsquo;t want to preface the docker command with sudo, create a Unix group called docker and add users to it. When the Docker daemon starts, it creates a Unix socket accessible by members of the docker group. On some Linux distributions, the system automatically creates this group when installing Docker Engine using a package manager. In that case, there is no need for you to manually create the group.\n― docker docs, Linux post-installation steps for Docker Engine 通过下面几步操作，可以将当前用户加入 docker 组，以后再使用 docker 就不需要输入 sudo 了。\n1 2 3 4 5 6 # 将当前用户加入 docker 组 sudo gpasswd -a ${USER} docker # 更新 docker 组 newgrp docker # 重启 docker 服务 sudo systemctl restart docker Reference Got permission denied | https://www.cnblogs.com/Li-JT/p/13994704.html\nhttps://www.runoob.com/docker\ndocker备份容器到本地（以及恢复） | https://blog.csdn.net/qq_20042935/article/details/106495071\n","date":"2021-10-08T11:24:42+08:00","permalink":"https://petrichor.net.cn/p/docker/","title":"Docker"},{"content":"特征 Golang 单元测试对文件名和方法名，参数都有很严格的要求。例如：\n文件名必须以 _test.go 结尾 方法名必须是 Test 开头 方法参数必须是 t *testing.T 或 b *testing.B 命令详解 go test 是 go 语言自带的测试工具，其中包含的是两类，单元测试(即 功能测试) 和 性能测试\n通过 go help test 可以看到 go test 的使用说明：\n格式： 1 go` `test [-c] [-i] [build flags] [packages] [flags ``for` `test binary] 参数： -c : 编译 go test 成为可执行的二进制文件，但是不运行测试。\n-i : 安装测试包依赖的 package，但是不运行测试。\n关于 build flags，调用 go help build，这些是编译运行过程中需要使用到的参数，一般设置为空\n关于 packages，调用 go help packages，这些是关于包的管理，一般设置为空\n关于 flags for test binary，调用 go help testflag，这些是 go test 过程中经常使用到的参数：\n-test.v : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例\n-test.run pattern : 只跑哪些单元测试用例\n-test.bench patten : 只跑那些性能测试用例\n-test.benchmem : 是否在性能测试的时候输出内存情况\n-test.benchtime t : 性能测试运行的时间，默认是1s\n-test.cpuprofile cpu.out : 是否输出cpu性能分析文件\n-test.memprofile mem.out : 是否输出内存性能分析文件\n-test.blockprofile block.out : 是否输出内部goroutine阻塞的性能分析文件\n-test.memprofilerate n : 内存性能分析的时候有一个分配了多少的时候才打点记录的问题。这个参数就是设置打点的内存分配间隔，也就是 profile 中一个 sample 代表的内存大小。默认是设置为 512 * 1024 的。如果你将它设置为 1，则每分配一个内存块就会在 profile 中有个打点，那么生成的 profile 的 sample 就会非常多。如果你设置为 0，那就是不做打点了\n你可以通过设置 memprofilerate=1 和 GOGC=off 来关闭内存回收，并且对每个内存块的分配进行观察\n-test.blockprofilerate n : 基本同上，控制的是 goroutine 阻塞时候打点的纳秒数。默认不设置就相当于 -test.blockprofilerate=1，每一纳秒都打点记录一下\n-test.parallel n : 性能测试的程序并行 cpu 数，默认等于 GOMAXPROCS\n-test.timeout t : 如果测试用例运行时间超过 t，则抛出 panic\n-test.cpu 1,2,4 : 程序运行在哪些 CPU 上面，使用二进制的 1 所在位代表，和 nginx 的 nginx_worker_cpu_affinity 是一个道理\n-test.short : 将那些运行时间较长的测试用例运行时间缩短\n","date":"2021-08-07T22:06:42+08:00","permalink":"https://petrichor.net.cn/p/go-test/","title":"Go Test 单元测试简明教程"},{"content":"语言基础 main函数 main函数不能带参数\nmain函数不能定义返回值\nmain函数所在的包必须为main\nmain函数中可以使用flag包来获取和解析命令行参数\nGo程序的执行（启动）顺序 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：\n如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。\n然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。\n在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。 包/package\n注意包级别的常量名和函数等都是以大写字母开头,它们才可以像tempconv.AbZeroC这样被外部代码访问。\n除了包的导入路径,每个包还有一个包名,包名一般是短小的名字(并不要求包名是唯一的),包名在包的声明处指定。按照惯例,一个包的名字和包的导入路径的最后一个字段相同，故这里是tempconv。\n命名规范 package名字 保持package的名字和目录保持一致 尽量采取有意义的包名，简短，有意义 尽量和标准库不要冲突。 文件命名 import规范 单包引入 1 import \u0026#34;fmt\u0026#34; 多包引入，每个包独占一行，按首字母排序（一般由ide来完成） 1 2 3 4 5 6 import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) 常量声明 变量声明 函数声明 结构体声明 接口命名 占位符 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式。 Printf(\u0026quot;%v\u0026quot;, people) {zhangsan} %+v 打印结构体时，会添加字段名 Printf(\u0026quot;%+v\u0026quot;, people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(\u0026quot;#v\u0026quot;, people) main.Human{Name:\u0026ldquo;zhangsan\u0026rdquo;} %T 相应值的类型的Go语法表示 Printf(\u0026quot;%T\u0026quot;, people) main.Human %% 字面上的百分号，并非值的占位符 Printf(\u0026quot;%%\u0026quot;) % 布尔占位符 占位符 说明 举例 输出 %t true 或 false Printf(\u0026quot;%t\u0026quot;, true) true 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(\u0026quot;%b\u0026quot;, 5) 101 %c 相应Unicode码点所表示的字符 Printf(\u0026quot;%c\u0026quot;, 0x4E2D) 中 %d 十进制表示 Printf(\u0026quot;%d\u0026quot;, 0x12) 18 %o 八进制表示 Printf(\u0026quot;%d\u0026quot;, 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(\u0026quot;%q\u0026quot;, 0x4E2D) \u0026lsquo;中\u0026rsquo; %x 十六进制表示，字母形式为小写 a-f Printf(\u0026quot;%x\u0026quot;, 13) d %X 十六进制表示，字母形式为大写 A-F Printf(\u0026quot;%x\u0026quot;, 13) D %U Unicode格式：U+1234，等同于 \u0026ldquo;U+%04X\u0026rdquo; Printf(\u0026quot;%U\u0026quot;, 0x4E2D) U+4E2D 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %b 无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 \u0026lsquo;b\u0026rsquo; 转换格式一致。例如 -123456p-78 %e 科学计数法，例如 -1234.456e+78 Printf(\u0026quot;%e\u0026quot;, 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(\u0026quot;%e\u0026quot;, 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(\u0026quot;%f\u0026quot;, 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\u0026quot;%g\u0026quot;, 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\u0026quot;%G\u0026quot;, 10.20+2i) (10.2+2i) 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(\u0026quot;%s\u0026quot;, []byte(\u0026ldquo;Go语言\u0026rdquo;)) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(\u0026quot;%q\u0026quot;, \u0026ldquo;Go语言\u0026rdquo;) \u0026ldquo;Go语言\u0026rdquo; %x 十六进制，小写字母，每字节两个字符 Printf(\u0026quot;%x\u0026quot;, \u0026ldquo;golang\u0026rdquo;) 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(\u0026quot;%X\u0026quot;, \u0026ldquo;golang\u0026rdquo;) 676F6C616E67 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(\u0026quot;%p\u0026quot;, \u0026amp;people) 0x4f57f0 其它标记 占位符 说明 举例 输出 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 Printf(\u0026quot;%+q\u0026quot;, \u0026ldquo;中文\u0026rdquo;) \u0026ldquo;\\u4e2d\\u6587\u0026rdquo; - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o） 为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x； 如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串； 如果是可打印字符，%U（%#U）会写出该字符的 Unicode 编码形式（如字符 x 会被打印成 U+0078 \u0026lsquo;x\u0026rsquo;）。 Printf(\u0026quot;%#U\u0026quot;, \u0026lsquo;中\u0026rsquo;) U+4E2D \u0026rsquo; ' (空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开 无 无 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 无 无 其他 golang没有 \u0026lsquo;%u\u0026rsquo; 点位符，若整数为无符号类型，默认就会被打印成无符号的。\n宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。 操作数的类型为int时，宽度与精度都可用字符 \u0026lsquo;*\u0026rsquo; 表示。\n对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。\n%e 和 %f 的默认精度为6\n对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。\n而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。\n作者：Juha 链接：https://www.jianshu.com/p/66aaf908045e 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n注释 README 其他 断言 Go基本命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 go build // 用于打包编译代码 go clean // 来移除当前源码包和关联源码包里面编译生成的文件 go fmt // 格式化代码文件 go get // 下载安装包 go install // 这里就是先生成结果文件，然后把这个文件放到我们的包里面去 go test // 测试文件自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件 // go提供的一些工具 go tool fix //用来修复以前老版本的代码到新版本 go tool vet directory|files //用来分析当前目录的代码是否都是正确的代码 // 用于在编译前自动化生成某类代码。go generate和go build是完全不一样的命令，通过分析源码中特殊的注释，然后执行相应的命令。这些命令都是很明确的，没有任何的依赖在里面。而且大家在用这个之前心里面一定要有一个理念，这个go generate是给你用的，不是给使用你这个包的人用的，是方便你来生成一些代码的。 go generate go doc // 生成文档 go version //查看go当前的版本 go env //查看当前go的环境变量 go list //列出当前全部安装的package go run //编译并运行Go程序 Go mod 相关命令 1 2 3 4 5 6 7 8 9 10 go mod init example.com //生成go.mod文件 go mod download //下载go.mod文件中知名的所有依赖 go mod tidy //整理现有的依赖，删除未使用的依赖 go mod graph //查看现有的依赖结构 go mod edit // 编辑go.mod文件 go mod vendor //到处现有的所有依赖 (事实上 Go modules 正在淡化 Vendor 的概念) go mod verify //校验一个模块是否被篡改过 go clean -modcache //清理所有已缓存的模块版本数据 go mod //查看所有go mod的使用命令 go mod why //explain why packages or modules are needed 未完待续。。。 参考文献 https://www.jianshu.com/p/66aaf908045e ","date":"2021-08-07T22:06:41+08:00","image":"https://petrichor.net.cn/go.png","permalink":"https://petrichor.net.cn/p/go/","title":"『Go』语言基础"}]